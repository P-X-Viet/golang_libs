package main

import (
	"fmt"
	"math"
	"math/rand"
	"time"
)

// BoundingBox defines the geographical boundary
type BoundingBox struct {
	MinLat float64 // Lower-left latitude
	MinLon float64 // Lower-left longitude
	MaxLat float64 // Upper-right latitude
	MaxLon float64 // Upper-right longitude
}

// Position represents a GPS coordinate
type Position struct {
	Lat float64
	Lon float64
}

// VehicleSimulator handles vehicle movement simulation
type VehicleSimulator struct {
	VehicleType    int
	BBox           BoundingBox
	CurrentPos     Position
	CurrentBearing float64 // Track current bearing
	rand           *rand.Rand
}

// NewVehicleSimulator creates a new vehicle simulator
func NewVehicleSimulator(vehicleType int, bbox BoundingBox, startPos Position) *VehicleSimulator {
	r := rand.New(rand.NewSource(time.Now().UnixNano()))
	return &VehicleSimulator{
		VehicleType:    vehicleType,
		BBox:           bbox,
		CurrentPos:     startPos,
		CurrentBearing: r.Float64() * 360.0, // Random initial bearing
		rand:           r,
	}
}

// getDistanceByType returns distance in meters based on vehicle type
func (vs *VehicleSimulator) getDistanceByType() float64 {
	switch vs.VehicleType {
	case 1:
		return 10.0 // 10 meters
	case 2:
		return 2.0 // 2 meters
	case 3:
		return 5.0 // 5 meters
	case 4:
		return 15.0 // 15 meters
	default:
		return 10.0
	}
}

// generateNewBearing generates a new bearing within 30 degrees of current bearing
func (vs *VehicleSimulator) generateNewBearing() float64 {
	// Random change between -30 and +30 degrees
	bearingChange := (vs.rand.Float64() * 60.0) - 30.0
	newBearing := vs.CurrentBearing + bearingChange
	
	// Normalize to 0-360 range
	newBearing = math.Mod(newBearing+360.0, 360.0)
	
	return newBearing
}

// moveToNewPosition generates next position within bounding box
func (vs *VehicleSimulator) moveToNewPosition() Position {
	distance := vs.getDistanceByType()
	
	// Generate new bearing within 30 degrees of current bearing
	bearing := vs.generateNewBearing()
	
	// Try to move in the new direction
	newPos := vs.calculateNewPosition(vs.CurrentPos, distance, bearing)
	
	// If new position is outside bounds, try alternative bearings
	attempts := 0
	maxAttempts := 12
	
	for !vs.isWithinBounds(newPos) && attempts < maxAttempts {
		// Try smaller bearing changes to stay within bounds
		bearingChange := (vs.rand.Float64() * 60.0) - 30.0
		bearing = vs.CurrentBearing + bearingChange
		bearing = math.Mod(bearing+360.0, 360.0)
		
		newPos = vs.calculateNewPosition(vs.CurrentPos, distance, bearing)
		attempts++
	}
	
	// If still outside bounds, calculate bearing towards center with adjustment
	if !vs.isWithinBounds(newPos) {
		centerLat := (vs.BBox.MinLat + vs.BBox.MaxLat) / 2
		centerLon := (vs.BBox.MinLon + vs.BBox.MaxLon) / 2
		bearingToCenter := vs.calculateBearing(vs.CurrentPos, Position{Lat: centerLat, Lon: centerLon})
		
		// Adjust current bearing gradually towards center (within 30 degree constraint)
		bearingDiff := vs.angleDifference(vs.CurrentBearing, bearingToCenter)
		if math.Abs(bearingDiff) > 30.0 {
			if bearingDiff > 0 {
				bearing = vs.CurrentBearing + 30.0
			} else {
				bearing = vs.CurrentBearing - 30.0
			}
		} else {
			bearing = bearingToCenter
		}
		bearing = math.Mod(bearing+360.0, 360.0)
		
		newPos = vs.calculateNewPosition(vs.CurrentPos, distance, bearing)
	}
	
	// Clamp to boundaries as final safeguard
	newPos.Lat = math.Max(vs.BBox.MinLat, math.Min(vs.BBox.MaxLat, newPos.Lat))
	newPos.Lon = math.Max(vs.BBox.MinLon, math.Min(vs.BBox.MaxLon, newPos.Lon))
	
	// Update current bearing for next iteration
	vs.CurrentBearing = bearing
	vs.CurrentPos = newPos
	
	return newPos
}

// angleDifference calculates the shortest angle difference between two bearings
func (vs *VehicleSimulator) angleDifference(bearing1, bearing2 float64) float64 {
	diff := bearing2 - bearing1
	
	// Normalize to -180 to 180
	for diff > 180.0 {
		diff -= 360.0
	}
	for diff < -180.0 {
		diff += 360.0
	}
	
	return diff
}

// calculateNewPosition computes new lat/lon given distance and bearing
func (vs *VehicleSimulator) calculateNewPosition(pos Position, distanceMeters float64, bearingDegrees float64) Position {
	earthRadiusMeters := 6371000.0
	
	// Convert to radians
	lat1 := pos.Lat * math.Pi / 180.0
	lon1 := pos.Lon * math.Pi / 180.0
	bearingRad := bearingDegrees * math.Pi / 180.0
	
	// Calculate new position using Haversine formula
	angularDistance := distanceMeters / earthRadiusMeters
	
	lat2 := math.Asin(math.Sin(lat1)*math.Cos(angularDistance) +
		math.Cos(lat1)*math.Sin(angularDistance)*math.Cos(bearingRad))
	
	lon2 := lon1 + math.Atan2(
		math.Sin(bearingRad)*math.Sin(angularDistance)*math.Cos(lat1),
		math.Cos(angularDistance)-math.Sin(lat1)*math.Sin(lat2))
	
	// Convert back to degrees
	return Position{
		Lat: lat2 * 180.0 / math.Pi,
		Lon: lon2 * 180.0 / math.Pi,
	}
}

// calculateBearing calculates bearing from pos1 to pos2
func (vs *VehicleSimulator) calculateBearing(pos1, pos2 Position) float64 {
	lat1 := pos1.Lat * math.Pi / 180.0
	lat2 := pos2.Lat * math.Pi / 180.0
	lonDiff := (pos2.Lon - pos1.Lon) * math.Pi / 180.0
	
	y := math.Sin(lonDiff) * math.Cos(lat2)
	x := math.Cos(lat1)*math.Sin(lat2) - math.Sin(lat1)*math.Cos(lat2)*math.Cos(lonDiff)
	bearing := math.Atan2(y, x)
	
	return math.Mod(bearing*180.0/math.Pi+360.0, 360.0)
}

// isWithinBounds checks if position is within bounding box
func (vs *VehicleSimulator) isWithinBounds(pos Position) bool {
	return pos.Lat >= vs.BBox.MinLat && pos.Lat <= vs.BBox.MaxLat &&
		pos.Lon >= vs.BBox.MinLon && pos.Lon <= vs.BBox.MaxLon
}

// GenerateNextPosition is the main function to call for getting next position
func (vs *VehicleSimulator) GenerateNextPosition() Position {
	return vs.moveToNewPosition()
}

// GetCurrentBearing returns the current bearing
func (vs *VehicleSimulator) GetCurrentBearing() float64 {
	return vs.CurrentBearing
}

// Example usage
func main() {
	// Define bounding box (example: area in Hanoi)
	bbox := BoundingBox{
		MinLat: 21.0000, // Lower-left
		MinLon: 105.8000,
		MaxLat: 21.0500, // Upper-right
		MaxLon: 105.8500,
	}
	
	// Starting position (center of bounding box)
	startPos := Position{
		Lat: (bbox.MinLat + bbox.MaxLat) / 2,
		Lon: (bbox.MinLon + bbox.MaxLon) / 2,
	}
	
	// Create simulator for vehicle type 1 (moves 10m per step)
	simulator := NewVehicleSimulator(1, bbox, startPos)
	
	fmt.Printf("Starting position: Lat=%.6f, Lon=%.6f, Bearing=%.2f°\n", 
		startPos.Lat, startPos.Lon, simulator.GetCurrentBearing())
	
	// Generate 10 position updates
	prevBearing := simulator.GetCurrentBearing()
	for i := 1; i <= 10; i++ {
		newPos := simulator.GenerateNextPosition()
		currentBearing := simulator.GetCurrentBearing()
		bearingChange := simulator.angleDifference(prevBearing, currentBearing)
		
		fmt.Printf("Position %d: Lat=%.6f, Lon=%.6f, Bearing=%.2f° (change: %+.2f°)\n", 
			i, newPos.Lat, newPos.Lon, currentBearing, bearingChange)
		
		prevBearing = currentBearing
		time.Sleep(1 * time.Second) // Simulate time between updates
	}
}
